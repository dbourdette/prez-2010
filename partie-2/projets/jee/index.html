<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Application web jee</title>

		<link href="../../../static/css.css" rel="stylesheet" type="text/css">
	    <link id="prettify-link" href="../../../static/prettify.css" rel="stylesheet">
	    <link href="../../../static/default.css" class="theme" rel="stylesheet">
	  	
	  	<link href="../../../static/dev.css" class="theme" rel="stylesheet">
	  	<link href="../../../static/project.css" class="theme" rel="stylesheet">
	    
	</head>
<body>
	<div id="project">
		<h1>Application web jee</h1>
		<h2>Présentation</h2>
		<p>Nous allons utiliser ce template de projet afin de se familiariser avec les servlets et les fichiers jsp.</p>
		<h2>Les outils utilsés :</h2>
		<ul>
			<li><a href="http://eclipse.org" class="external" target="_blank">eclipse</a> : un IDE gratuit pour java (et beaucoup d'autres langages)
			<li><a href="http://tomcat.apache.org" class="external" target="_blank">tomcat</a> : un conteneur de servlet de la fondation apache
		</ul>
		<p>Pour eclipse, si possible, prendre la distribution <a href="http://www.springsource.com/downloads/sts" class="external" target="_blank">SpringSource Tool Suite</a>
		<p>Il faut installer <a href="http://tomcat.apache.org/download-60.cgi" class="external" target="_blank">tomcat 6</a> où l'on souhaite. Un jdk 6 est requis.</p>
		<h2>Les ressources disponibles pour ce projet :</h2>
		<ul>
			<li>eclipse : le répertoire contenant le projet eclipse
			<li>index.html : ce fichier
			<li>images : les images de cette page web
			<li>lib : des librairies additionnelles
		</ul>
		<p>Le projet a été créé en utilisant le menu File &gt; New... &gt; Dynamic Web Project (nom : jee)</p>
		<p><b>Encodings sous eclipse</b> : eclipse est un outils multi plateformes et multi languages dont la configuration par défaut est parfois inadéquate.</p>
		<img alt="" src="images/encodings.png" width="400" style="float:left;margin:0 10px;"/>
		<p>Ce menu est accessible via Window &gt; Preferences</p>
		<p>Il permet de régler l'encoding par défaut et aussi l'encoding par type de fichier.</p>
		<p>C'est l'endroit où regarder en cas de problème d'encoding.</p>
		<p>Il est possible enfin de régler l'encoding fichier par fichier.</p>
		<div style="clear:both;"></div>
		<h2>La mise en place du projet</h2>
		<ol>
			<li>Ouvrir eclipse
			<li>Si tomcat n'est pas configuré, ajouter tomcat 6 à la liste des serveurs disponibles :
				<ul>
					<li>Windows &gt; Preferences
					<li>puis Server &gt; Runtime Environments
					<li>Add...
					<li><img alt="" src="images/add-tomcat.png" style="vertical-align: top;">
					<li>Choisir le répertoire d'installation de tomcat 6
					<li>Finish
					<li>Ok
				</ul>
			<li>Démarrer avec le projet eclipse
				<ul>
					<li>Importer le projet eclipse (File &gt; Import &gt; Existing project into workspace)
					<li>Ou en créer un (File &gt; New... &gt; Dynamic Web Project)
				</ul>
		</ol>
		<h2>Le projet eclipse</h2>
		<p>Sous eclipse, le projet ressemble à l'arborescence suivante</p>
		<img alt="" src="images/eclipse-jee.png" style="float:left;margin:30px 10px;">
		<ul>
			<li>src : les classes java
			<li>JRE System Library : les librairies du jre
			<li>Apache Tomcat v6.0 : les librairies de tomcat
			<li>build : le répertoire où sont compilés les classes
			<li>WebContent : les ressources web
			<li>WebContent/META-INF : les méta données liées au projet
			<li>WebContent/WEB-INF : les méta données web liées au projet
			<li>WebContent/WEB-INF/lib : les librairies utilisateur
			<li>WebContent/WEB-INF/web.xml : le descripteur de déploiement
		</ul>
		<h2>Le descripeur de déploiement</h2>
		<p>Il décrit comment le serveur d'application doit configurer et déployer les composants.</p>
		<pre>
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
   http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
  version="2.5"&gt;
 
   &lt;display-name&gt;jee&lt;/display-name&gt;
	
&lt;/web-app&gt;</pre>
		<p>Pour le moment, notre application ne fait que s'appeler jee</p>
		<h2>Lancement du serveur web</h2>
		<p>On peut lancer le conteneur tomcat avec le menu Run &gt; Run as... &gt; Run on Server.</p>
		<p>Ce menu est également accessible en menu contextuel (click droit) sur le projet.</p>
		<img alt="" src="images/tomcat-launch.png" style="margin:0 120px;">
		<p>Un click sur Finish et le serveur démarre.</p>
		<pre class="shell" style="overflow: hidden;">
27 janv. 2011 22:08:47 org.apache.catalina.core.AprLifecycleListener init
INFO: The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: C:\Program Files (x86)\Java\jdk1.6.0_22\bin;.;C:\Windows\Sun\Java\bin;C:\Windows\system32;C:\Windows;C:\Program Files\Common Files\Microsoft Shared\Windows Live;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files (x86)\ATI Technologies\ATI.ACE\Core-Static;C:\Program Files (x86)\apache-maven-2.1.0\bin;C:\Program Files (x86)\Java\jdk1.6.0_17\bin;C:\Program Files (x86)\jEdit;C:\Program Files (x86)\Subversion\bin;C:\Program Files (x86)\QuickTime\QTSystem\;C:\Program Files (x86)\gwt-2.1.0;C:\Program Files (x86)\apache-ant-1.8.1\bin;C:\Users\devarf\spring-roo-1.1.0.RELEASE\bin
27 janv. 2011 22:08:47 org.apache.tomcat.util.digester.SetPropertiesRule begin
ATTENTION: [SetPropertiesRule]{Server/Service/Engine/Host/Context} Setting property 'source' to 'org.eclipse.jst.jee.server:jee' did not find a matching property.
27 janv. 2011 22:08:47 org.apache.coyote.http11.Http11Protocol init
INFO: Initialisation de Coyote HTTP/1.1 sur http-8080
27 janv. 2011 22:08:47 org.apache.catalina.startup.Catalina load
INFO: Initialization processed in 630 ms
27 janv. 2011 22:08:47 org.apache.catalina.core.StandardService start
INFO: Démarrage du service Catalina
27 janv. 2011 22:08:47 org.apache.catalina.core.StandardEngine start
INFO: Starting Servlet Engine: Apache Tomcat/6.0.30
27 janv. 2011 22:08:47 org.apache.coyote.http11.Http11Protocol start
INFO: Démarrage de Coyote HTTP/1.1 sur http-8080
27 janv. 2011 22:08:48 org.apache.jk.common.ChannelSocket init
INFO: JK: ajp13 listening on /0.0.0.0:8009
27 janv. 2011 22:08:48 org.apache.jk.server.JkMain start
INFO: Jk running ID=0 time=0/15  config=null
27 janv. 2011 22:08:48 org.apache.catalina.startup.Catalina start
INFO: Server startup in 385 ms</pre>
		<p>Normalement <a href="http://localhost:8080/jee" target="_blank">une page 404</a> sur http://localhost:8080/jee devrait désormais répondre.</p>
		<p>Le nom jee à la fin de l'url est le nom de l'application. Il peut différer si le projet eclipse initial (et donc le nom de l'application dans le web.xml) n'est pas jee.</p>
		<h2>Lancement de tomcat en ligne de commande</h2>
		<p>Le lancement de tomcat via eclipse est pratique car il permet de le piloter sans quitter l'IDE.</p>
		<p>En production et même en local, il est possible de lancer le serveur tomcat en ligne de commande et de déployer le war manuellement.</p>
		<img alt="" src="images/shell-tomcat.png" style="float:left;margin:10px 10px;">
		<p>Pour lancer tomcat, il suffit d'aller dans le répertoire bin de l'installation.</p>
		<p>La commande de lancement est startup.sh ou startup.bat selon l'environnement.</p>
		<p>La commande d'arrêt est shutdown.sh ou shutdown.bat selon l'environnement.</p>
		<div style="clear:both;"></div>
		<p>Un fois démarré, il suffit de déposer le war dans le répertoire webapps de l'installation.</p>
		<img alt="" src="images/export-war.png" width="400" style="float:right;margin:0 10px;">
		<p>Avec eclipse, un war se crée facilement à partir d'un projet web via File &gt; Export... (war)</p>
		<p>Une fois le war déposé, tomcat devrait indiquer qu'il a vu et déployer l'application.</p>
		<p>On peut d'ailleurs voir dans le répertoire webapps, un répertoire correspondant à l'application.</p>
		<p>Il existe un nom de war spécial sous tomcat. Si l'application est déposée en tant que ROOT.war, elle sera déployé à la racine du serveur (http://localhost:8080/).</p>
		<p>En pratique, on utilise jamais eclipse pour faire un war en entreprise.</p>
		<p>On utilise un outils de build comment ant ou maven qui permet de rendre cette contruction automatisable et fiable.</p>
		<div style="clear:both;"></div>
		<h2>HelloWorldServlet</h2>
		<p>Nous allons utiliser eclipse afin de créer une servlet (File &gt; New &gt; Servlet) : HelloWorldServlet.</p>
		<p>Les options à choisir lors de la création de la classe :</p>
		<ul>
			<li> java package : fr.prez.jee
			<li> class name : HelloWorldServlet
			<li> method stubs : doGet
		</ul>
		<p>A la fin du wizard, on obtient la classe suivante :</p>
		<pre>
public class HelloWorldServlet extends HttpServlet {
  private static final long serialVersionUID = 1L;

  @Override
  protected void doGet(HttpServletRequest request, HttpServletResponse response)
	   				  throws ServletException, IOException {}
}</pre>
		<p>Demandons à la classe de dire bonjour :</p><pre>
protected void doGet(HttpServletRequest request, HttpServletResponse response)
  				     throws ServletException, IOException {
  <b>response.getWriter().write("Hello !");</b>
}</pre>
		<p>Si on jette un oeil au web.xml, eclipse a rajouté ce composant pour nous</p>
		<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app ...&gt;
  &lt;display-name&gt;jee sleleton&lt;/display-name&gt;
  &lt;servlet&gt;
    &lt;description&gt;&lt;/description&gt;
    &lt;display-name&gt;HelloWorldServlet&lt;/display-name&gt;
    &lt;servlet-name&gt;HelloWorldServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;fr.prez.jee.HelloWorldServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;HelloWorldServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/HelloWorldServlet&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre>
		<p>Il suffit alors de demander a tomcat de recharger l'application.</p>
		<img alt="" src="images/tomcat-restart.png" style="margin:0 150px;">
		<p>Note servlet répond sur <a href="http://localhost:8080/jee/HelloWorldServlet" target="_blank">http://localhost:8080/jee/HelloWorldServlet</a>.</p>
		<h2>Les paramètres</h2>
		<p>Il est possible d'exploiter les paramètres depuis la servlet.</p>
	    <pre>
public class HelloWorldSerlvet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    @Override
    protected void doGet(HttpServletRequest request,
                         HttpServletResponse response)
    	throws ServletException, IOException {
    	<b>String name = request.getParameter("name");</b>
    	
        response.getWriter().write(<b>"Hello " + name + " !"</b>);
    }
}</pre>
	      <p>Ce qui donne en résultat sur <a href="http://localhost:8080/jee/HelloWorldServlet?name=Steven" target="_blank">http://localhost:8080/jee/HelloWorldServlet?name=Steven</a>.</p>
	      <h2>Le redirect</h2>
	      <p>Création de HelloWorldRedirectServlet qui va faire un redirect vers HelloWorldSerlvet</p>
	          <pre>
public class HelloWorldRedirectServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request,
                         HttpServletResponse response)
    	throws ServletException, IOException {
    	response.sendRedirect("HelloWorldServlet");
    }
}</pre>
			<p>Ce qui donne en résultat sur <a href="http://localhost:8080/jee/HelloWorldRedirectServlet?name=Steven" target="_blank">http://localhost:8080/jee/HelloWorldRedirectServlet?name=Steven</a>.</p>
			<p>On peut voir le premier retour du serveur (302) sur le traceur de requête de Chrome.</p>
			<p>On note aussi que le paramètre name est perdu dans la redirection.</p>
			<h2>Les sessions</h2>
			<p>Création de HelloWorldSessionServlet afin de stoquer le nom en session.</p>
	          <pre>
public class HelloWorldSessionServlet extends HttpServlet {
    @Override
    protected void doGet(...) ... {
    	String name = request.getParameter("name");
    	
    	<b>request.getSession(true).setAttribute("name", name);</b>
    	   
    	response.getWriter().write("Stored " + name + " !");
    }
}</pre>
				<p>La nouvelle servlet <a href="http://localhost:8080/jee/HelloWorldSessionServlet?name=Steven" target="_blank">http://localhost:8080/jee/HelloWorldSessionServlet?name=Steven</a>.</p>
				<p>Modifions notre première servlet afin qu'elle en profite</p>
<pre>
public class HelloWorldSerlvet extends HttpServlet {
    @Override
    protected void doGet(...) ... {
    	String name = request.getParameter("name");
		
        if (name == null) {
           <b>name = (String) request.getSession(true).getAttribute("name");</b>
        }
    	
        response.getWriter().write("Hello " + name + " !");
    }
}</pre>
			<p>Notre première servlet supporte l'absence de paramètre <a href="http://localhost:8080/jee/HelloWorldServlet" target="_blank">http://localhost:8080/jee/HelloWorldServlet</a>
			si la variable est en session.</p>
			<h2>Générer du HTML</h2>
			<p>Il est possible de faire du html depuis une servlet.</p>
	          <pre>
public class HelloWorldSerlvet extends HttpServlet {
    @Override
    protected void doGet(...) ... {
    	PrintWriter writer = response.getWriter();
    	
        writer.write("&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Hello !&lt;/body&gt;&lt;/html&gt;");
    }
}</pre>
			<p>Le résultat sur <a href="http://localhost:8080/jee/HelloWorldServlet" target="_blank">http://localhost:8080/jee/HelloWorldServlet</a>.</p>
			<p>Sous chrome, on peut bien observer l'arbre DOM</p>
			<img alt="" src="images/jee-skeleton-dom-tree.png" style="margin:0 50px;"/>
			<p>Mais cette méthode est complètement inadaptée dès que la page web dépasse quelques lignes.</p>
			<h2>Les fichiers jsp</h2>
			<p>La création du rendu HTML est le rôle des fichiers jsp. La servlet passe donc la main à une jsp.</p>
	          <pre>
public class HelloWorldSerlvet extends HttpServlet {
    @Override
    protected void doGet(...) ... {
    	<b>request.setAttribute("name", request.getParameter("name"));</b>

        <b>request.getRequestDispatcher("/WEB-INF/jsp/hello.jsp")
           .forward(request, response);</b>
    }
}
	          </pre>
	          <p>Il faut créer le fichier WebContent/WEB-INF/jsp/hello.jsp (File &gt; New &gt; JSP File) :</p>
	          <pre>
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
   &lt;head&gt;&lt;/head&gt;
   &lt;body&gt;Hello ${name} !&lt;/body&gt;
&lt;/html&gt;</pre>
	          <p>Le résultat sur <a href="http://localhost:8080/jee/HelloWorldServlet?name=Steven" target="_blank">http://localhost:8080/jee/HelloWorldServlet?name=Steven</a>.</p>
	          <h2>Les tag files</h2>
	          <p>Les tags sont des nouveaux éléments du language des jsp que l'on peut définir soit même.</p>
	          <p>On ajoute le fichier hello.tag dans le répertoire WEB-INF/tags/widget.</p>
	          <pre>
&lt;%@ tag language="java" pageEncoding="UTF-8"%&gt;

&lt;%@ attribute name="name" description="Name to display" required="true"
 type="java.lang.String" %&gt;

Hello ${name} ! from tag</pre>
			  <p>Ce qui nous autorise à faire l'appel suivant dans notre jsp.</p>
			  <pre>
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%&gt;
    
<b>&lt;%@ taglib tagdir="/WEB-INF/tags/widget" prefix="widget" %&gt;</b>
    
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
   &lt;head&gt;&lt;/head&gt;
   &lt;body&gt;<b>&lt;widget:hello name="${name}" /&gt;</b>&lt;/body&gt;
&lt;/html&gt;</pre>
			  <p>Cela donne donc des nouveaux éléments du language jsp prochent du language html.</p>
			  <p>Il est aussi possible de déclarer ses tags files en utilisant une synthaxe xml.</p>
			  <h2>Les custom tags</h2>
			  <p>Les tag files sont parfaits afin d'écrire du code jsp réutilisable.</p>
			  <p>Dans d'autres cas, le code à réutiliser contient davantage de logique que de html et coder en jsp deviennent malaisé.</p>
			  <p>Les custom tags sont un peu plus compliqués à mettre en place mais ils sont écrit en java.</p>
			  <p>On ajout le fichier test.tld dans WEB-INF/tld.</p>
			  <pre>
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;taglib xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee 
	web-jsptaglibrary_2_0.xsd" version="2.0"&gt;
	
  &lt;tlibversion&gt;1.0&lt;/tlibversion&gt;
  &lt;jspversion&gt;2.0&lt;/jspversion&gt;
  &lt;shortname&gt;link&lt;/shortname&gt;
  &lt;uri&gt;<b>http://fr.prez.jee/test</b>&lt;/uri&gt;
  &lt;info&gt;Test taglib&lt;/info&gt;

  &lt;tag&gt;
    &lt;name&gt;hello&lt;/name&gt;
    &lt;tagclass&gt;<b>fr.prez.jee.HelloTag</b>&lt;/tagclass&gt;
    &lt;body-content&gt;empty&lt;/body-content&gt;
    &lt;info&gt;Prints name&lt;/info&gt;
    &lt;attribute&gt;
      &lt;name&gt;name&lt;/name&gt;
      &lt;required&gt;true&lt;/required&gt;
      &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;
    &lt;/attribute&gt;
  &lt;/tag&gt;

&lt;/taglib&gt;</pre>
			  <p>Ensuite on ajoute la clase HelloTag.</p>
			  <pre>
public class HelloTag extends SimpleTagSupport {

  private String name;
  
  @Override
  public void doTag() throws JspException, IOException {
    getJspContext().getOut().print("Hello " + name + " from custom tag");
  }

  public void setName(String name) {
    this.name = name;
  }

}</pre>
			  <p>Enfin on peut modifier notre fichier jsp.</p>
			  <pre>
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%&gt;
    
&lt;%@ taglib tagdir="/WEB-INF/tags/widget" prefix="widget" %&gt;
&lt;%@ taglib uri="http://fr.prez.jee/test" prefix="test" %&gt;
    
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;widget:hello name="${name}" /&gt;&lt;br&gt;
    <b>&lt;test:hello name="${name}" /&gt;</b>
  &lt;/body&gt;
&lt;/html&gt;</pre>
			  <p>Custom tags et tag files sont solutions complémentaires.</p> 
    	      <p>Les fichiers tld et les custom tags peuvent être facilement intégrés à des jar et donc être réutilisables entre plusieurs projets.</p>  
	          <h2>La gestion d'erreur</h2>
	          <p>Le traitement d'un requête peut impliquer un nombre important d'objets et une erreur peut survenir à n'importe quel stade du traitement.</p>
	          <img alt="" src="images/error-handling.png" width="700" style="margin:0 80px;"/>
	          <p>Par défaut, il est donc intéressant d'avoir un mécanisme générique, une sorte de filet, qui récupère toutes ces erreurs et produit un resultat pour le client.</p>
	          <p>Actuellement, si on génère une erreur, on obtient la page d'erreur par défaut.</p>
	          <pre>
public class HelloWorldSerlvet extends HttpServlet {
    @Override
    protected void doGet(...) ... {
    	throw new NullPointerException("ups !");
    }
}
	          </pre>
	          <p>Le résultat est assez sec <a href="http://localhost:8080/jee/HelloWorldServlet" target="_blank">http://localhost:8080/jee/HelloWorldServlet</a></p>
	          <p>Une configuration simple du web.xml permet de traiter ce genre d'erreur.</p>
	          <pre>
&lt;error-page&gt;
   &lt;error-code&gt;500&lt;/error-code&gt;
   &lt;location&gt;/WEB-INF/jsp/500.jsp&lt;/location&gt;
&lt;/error-page&gt;</pre>
			<p>Et la jsp WEB-INF/jsp/500.jsp correspondant.</p>
			<pre>
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
   &lt;head&gt;&lt;/head&gt;
   &lt;body&gt;Erreur 500&lt;/body&gt;
&lt;/html&gt;</pre>
			<p>Ce qui permettrait de produire une réponse mise en forme sur <a href="http://localhost:8080/jee/HelloWorldServlet" target="_blank">http://localhost:8080/jee/HelloWorldServlet</a></p>
			<h2>Les filtres</h2>
			<p>Les filtres sont des composants qui interceptent les requêtes</p>
			<p>Nous créons le filtre suivant GuardFilter (File &gt; New... &gt; Filter)</p>
			<pre>
public void doFilter(ServletRequest request, ServletResponse response,
         FilterChain chain) throws IOException, ServletException {
   try {
      chain.doFilter(request, response);
   } catch (Exception e) {
      response.getWriter().write("got you !");
   }
}</pre>
			<p>En prenant soin de modifier le web.xml.</p>
			<pre>
&lt;filter&gt;
  &lt;display-name&gt;GuardFilter&lt;/display-name&gt;
  &lt;filter-name&gt;GuardFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;fr.prez.jee.GuardFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;GuardFilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</pre>
			<p>Sur la requête <a href="http://localhost:8080/jee/HelloWorldServlet" target="_blank">http://localhost:8080/jee/HelloWorldServlet</a>, le filtre a intercepté l'erreur et répondu.</p>
			<p>Les filtres sont très pratiques afin d'implémenter des problématiques transverses telles que la sécurité ou la libération de ressources.</p>
			<h2>Un cas concret</h2>
			<p><a href="http://code.google.com/p/javamelody" class="external" target="_blank">javamelody</a> est une librairie qui s'intègre à une application et permet de la monitorer.</p>
			<p>Il suffit de recopier les jars présents dans le répertoire lib vers le répertoire WEB-INF/lib et de changer le web.xml.</p>
			<p>Si on copie un fichier via sur le filesystem d'un projet en dehors d'eclipse, il faut demander au projet se rafraîchir (File &gt; Refresh) afin que le fichier soit pris en compte.</p>
			<pre>
&lt;filter&gt;
   &lt;filter-name&gt;monitoring&lt;/filter-name&gt;
   &lt;filter-class&gt;net.bull.javamelody.MonitoringFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
   &lt;filter-name&gt;monitoring&lt;/filter-name&gt;
   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
&lt;listener&gt;
   &lt;listener-class&gt;net.bull.javamelody.SessionListener&lt;/listener-class&gt;
&lt;/listener&gt;
			</pre>
			<p>Javamelody analyse tout ce qui se passe dans le serveur et est capable de fournir énormément d'information sur l'application.</p>
			<p>Après quelques requêtes, on peut lire un rapport sur <a href="http://localhost:8080/jee/monitoring" target="_blank">http://localhost:8080/jee/monitoring</a>.</p>
			<p>Dans notre cas, nous avons peu de composants. Dans une application réelle, javamelody fournit des informations sur tous les services standards et les librairies les plus utilisées.</p>
		</div>
	</body>
</html>